/*! \file 

\page des The DES Tool

\section background_des64 Background

The Data Encryption Standard (DES) is a symmetric-key algorithm which was used for computer
security for a long time. It is now considered to be unsecure, but it was still very 
influential in the field of electronic encryption.

This specific implemention performs only the Electronic Code Book (ECB) encryption mode
of the DES. In this mode, each block of data is encrypted/decrypted entirely indepenedently
from the others.

The DES works on blocks of 64 bits at a time, and processes them in 16 rounds of encryption.
In each round, the block generated by the previous round is permuted, XORed, and generally mixed around
before being returned. In addition, the key is used to generate a sub-key which is used in each round, and 
each round makes use of a set of S-Boxes. The S-Boxes are mappings which take 6-bit values and return 4-bit values.

One of the important design points of the DES is that rounds can happen exactly the same during
encryption and decryption; the only difference is that the sub-keys are used in reverse order. This means
that very efficient hardware could be build to do the algorithm and then used for both cases.

\section compile_des64 Compiling
This tool can be built with the command 
\verbatim 
make
\endverbatim
This will generate a release version of the tool in the release directory. To build a debug version in the debug directory,
use the command 
\verbatim
make BUILD_TYPE=debug
\endverbatim

\section usage_des64 Usage
This tool can be used to encrypt and decrypt messages.

\verbatim
tool_des64 mode input output key
\endverbatim
Mode Options
    - -e : To encrypt
    - -d : To decrypt

Input Options
    - -it text : To input the text 'text'
    - -if file : To input from the file 'file'

Output Options
    - -ot : To output to terminal
    - -of file : To output to the file 'file'

Key Options
    - -k key : The key to use, written as 16 hexadecimal characters

The key needs to pass the DES parity check; each byte should have an odd number of 1's in it.
When input mode is -it, it is expected that the input is a single block (64-bits) in hexadecimal
When output mode is -ot, data will be outputted in hexadecimal
*/
#include <iostream>
#include <string>
#include <fstream>
#include <sstream>
#include <cctype>
#include <functional>
#include <stdexcept>

#include "des64.h"

using namespace std;
using namespace des64;

//! Enums for this tool
namespace enums {
    //! Input options
    enum class Input{None, File, Term};

    //! Output options
    enum class Output{None, File, Term};

    //! Mode options
    enum class Mode{None, Encrypt, Decrypt};
}

using namespace enums;

/*! Processes the command line arguments

If the arguments are invalid, a usage prompt is printed with an error message

\param[in] argc Number of arguments
\param[in] argv The arguments
\param[out] inMode Mode of input
\param[out] outMode Mode of output
\param[out] op The operation to perform
\param[out] key The key to use for encryption or decryption
\param[out] input String to process if text mode, file name if file mode
\param[out] output File name to output to
\returns bool - Whether or not the arguments were valid
*/
bool processArgs(int argc, char** argv, Input& inMode, Output& outMode, Mode& op, string& key, string& input, string& output);

/*! Prints the program usage prompt with an error message

\param[in] name Name of the program
\param[in] msg Error message to print
*/
void help(string name, string msg = "");

/*! Converts hexadecimal values to a string of characters. Each character is made from two hex values.

\param[in] input Characters to convert
\returns string - The ASCII output
*/
string charsFromHex(string input);

/*! Converts characters to hexadecimal values. Each character becomes two values

\param[in] input Characters to convert
\returns string - The hexadecimal output
*/
string hexFromChars(string input);

/*!
    Processes the command line arguments. If they are invalid, the application terminates. 

    The key is converted from hex to a 64-bit value. If it is not 16 hex values long,
    the application terminates.

    Any files that will be used are opened. If text is used as the input, it is copied
    into an input stream. If a file fails to open, the application terminates.

    Data is processed 8 bytes at a time (16 if reading hexadecimal) and written to
    the output in the same format. If the key parity fails, the application terminates.
    If 8 bytes are not available, 0's are appended

    \param[in] argc Number of command line arguments
    \param[in] argv The command line arguments
    \returns 0 - The program ran successfully
    \returns 1 - The command line arguments were invalid
    \returns 2 - A file could not be opened
    \returns 3 - The key was the wrong size
    \returns 4 - The input was supposed to be hexadecmal, but was not valid
    \returns 5 - The key parity check failed
*/
int main(int argc, char** argv)
{
    string key, input, output;
    Input inputMode;
    Output outputMode;
    Mode operation;

    stringstream inText;

    ifstream inFile;
    ofstream outFile;

    istream* inStream = &inText;
    ostream* outStream = &cout;

    if(!processArgs(argc, argv, inputMode, outputMode, operation, key, input, output))
    {
        return 1;
    }

    uint64_t key_val = 0;
    try
    {
        if(key.size() != 16)
            throw logic_error("");
        
        key_val = stoull(key, 0, 16);
    }catch(exception& ex)
    {
        help(argv[0], "Key must contain exactly 16 hexadecimal characters [0-9, a-f]");
        return 3;
    }

    if(inputMode == Input::File)
    {
        inFile.open(input, ios::binary);
        if(!inFile)
        {
            help(argv[0], "Unable to open input file " + input);
            return 2;
        }

        inStream = &inFile;
    }
    else
    {
        try
        {
            inText << charsFromHex(input);  
        }catch(exception)
        {
            help(argv[0], input + " is not a valid hexadecimal value");
            return 4;
        }
    }

    if(outputMode == Output::File)
    {
        outFile.open(output, ios::binary | ios::trunc);
        if(!outFile)
        {
            help(argv[0], "Unable to open output file " + output);
            inFile.close();
            return 2;
        }

        outStream = &outFile;
    }

    function<uint64_t(uint64_t, const uint64_t&)> op = (operation == Mode::Encrypt ? encrypt : decrypt);

    uint64_t block;
    bool done = false;
    while(*inStream)
    {
        block = 0;
        for(int i=0; i<8 && *inStream; i++)
        {
            unsigned char byte;
            inStream->read((char*)&byte, 1);

            if(!*inStream)
            {
                done = true;
            }
            else
            {
                block |= ((uint64_t)byte << ((7-i) * 8));
            }
        }
        if(done) break;

        try
        {
            block = op(block, key_val);
        }catch(exception)
        {
            cerr << "Key parity fails" << endl;
            inFile.close();
            outFile.close();
            return 5;
        }
        
        unsigned char block_chars[8];
        for(int i=0; i<8; i++)
        {
            block_chars[7-i] = (block & 0xFF);
            block >>= 8;
        }

        if(outputMode == Output::File)
        {
            outStream->write((char*)block_chars, 8);
        }
        else
        {
            *outStream << hexFromChars(string((char*)block_chars, 8));
        }
    }

    inFile.close();
    outFile.close();

    return 0;
}

bool processArgs(int argc, char** argv, Input& inMode, Output& outMode, Mode& op, string& key, string& input, string& output)
{
    inMode = Input::None;
    outMode = Output::None;
    op = Mode::None;

    for(int i=1; i<argc; i++)
    {
        string arg = argv[i];

        if(arg == "-k")
        {
            if(i >= argc-1)
            {
                help(argv[0], "Enter key with -k [key]");
                return false;
            }
            i++;
            key = argv[i];
        }
        else if(arg == "-it")
        {
            if(inMode != Input::None)
            {
                help(argv[0], "Choose exactly one input mode [-it, -if]");
                return false;
            }

            inMode = Input::Term;

            if(i >= argc-1)
            {
                help(argv[0], "Enter text with -it {text}");
                return false;
            }

            i++;
            input = argv[i];
        }
        else if(arg == "-if")
        {
            if(inMode != Input::None)
            {
                help(argv[0], "Choose exactly one input mode [-it, -if]");
                return false;
            }

            inMode = Input::File;

            if(i >= argc-1)
            {
                help(argv[0], "Enter file name with -if {file}");
                return false;
            }

            i++;
            input = argv[i];
        }
        else if(arg == "-ot")
        {
            if(outMode != Output::None)
            {
                help(argv[0], "Choose exactly one output mode [-ot, -of]");
                return false;
            }

            outMode = Output::Term;
        }
        else if(arg == "-of")
        {
            if(outMode != Output::None)
            {
                help(argv[0], "Choose exactly one output mode [-ot, -of]");
                return false;
            }

            outMode = Output::File;

            if(i >= argc-1)
            {
                help(argv[0], "Enter file name with -of {file}");
                return false;
            }

            i++;
            output = argv[i];
        }
        else if(arg == "-e")
        {
            if(op != Mode::None)
            {
                help(argv[0], "Choose exactly one operation [-e, -d]");
                return false;
            }

            op = Mode::Encrypt;
        }
        else if(arg == "-d")
        {
            if(op != Mode::None)
            {
                help(argv[0], "Choose exactly one operation [-e, -d]");
                return false;
            }

            op = Mode::Decrypt;
        }
        else
        {
            help(argv[0], "Unknown option: " + arg);
            return false;
        }
    }

    if(op == Mode::None)
    {
        help(argv[0], "Choose exactly one operation [-e, -d]");
        return false;
    }

    if(inMode == Input::None)
    {
        help(argv[0], "Choose exactly one input mode [-it, -if]");
        return false;
    }

    if(outMode == Output::None)
    {
        help(argv[0], "Choose exactly one output mode [-ot, -of]");
        return false;
    }

    return true;
}

void help(string name, string msg)
{
    cout << msg << endl << endl;

    cout << "tool_des64 mode input output key\n\
Mode Options\n\
    -e : To encrypt\n\
    -d : To decrypt\n\
    \n\
Input Options\n\
    -it text : To input the text 'text'\n\
    -if file : To input from the file 'file'\n\
    \n\
Output Options\n\
    -ot : To output to terminal\n\
    -of file : To output to the file 'file'\n\
    \n\
Key Options\n\
    -k key : The key to use, written as 16 hexadecimal characters\n\
    \n\
The key needs to pass the DES parity check; each byte should have an odd number of 1's in it.\n\
When input mode is -it, it is expected that the input is a single block (64-bits) in hexadecimal\n\
When output mode is -ot, data will be outputted in hexadecimal" << endl;
}

string charsFromHex(string input)
{
    string out = "";
    for(char& c : input) c = tolower(c);
    if(input.find_first_not_of("0123456789abcdef") != string::npos)
        throw logic_error("");

    if(input.size() % 2 == 1) input = input + "0";
    for(int i=0; i<input.size(); i+=2)
    {
        out.push_back((input[i] >= 'a' ? input[i] - 'a' + 10 : input[i] - '0') << 4 |
                      (input[i+1] >= 'a' ? input[i+1] - 'a' + 10 : input[i+1] - '0'));
    }

    return out;
}

string hexFromChars(string input)
{
    string out = "";
    for(char c1 : input)
    {
        unsigned char c = c1;
        out.push_back((c >> 4) >= 10 ? (c >> 4) - 10 + 'a' : (c >> 4) + '0');
        out.push_back((c & 0xF) >= 10 ? (c & 0xF) - 10 + 'a' : (c & 0xF) + '0');        
    }
    return out;
}