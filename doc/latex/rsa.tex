\hypertarget{rsa_background_rsa}{}\section{background\+\_\+rsa}\label{rsa_background_rsa}
The R\+SA (Rivest–\+Shamir–\+Adleman) algorithm is a public/private key system based upon the commonly accepted idea that factoring very large numbers is difficult.

The general algorithm is as follows
\begin{DoxyItemize}
\item Person A picks two large numbers, $ p $ and $ q $
\item Person A computes $ n = p*q $
\item Person A computes $ \phi(n) = (p-1)(q-1)$
\item Person A picks some $ e $, the encryption exponent, such that $ 1 < e < \phi(n) $ and $ gcd(e, \phi(n)) = 1 $
\item Person A computes $ d $ such that $ de = 1 $ mod $ \phi(n) $
\item Person A publishes $ e, n $ -\/ This is the public key
\item Person B has a message $ m $ to send Person A
\item Person B computes $ c = m^e$ mod $ n $ (If $ m > n $, break it into pieces)
\item Person B sends $ c $ to Person A
\item Person A decrypts $ m = c^d $ mod $ n $
\end{DoxyItemize}

The basis for this algorithm lies in Fermat\textquotesingle{}s Little Theorem( $ a^{p-1} = 1 $ mod $ p $) and the fact that $ ed = 1 $ mod $ \phi(n) $.

We can write $ ed-1 = 0 $ mod $ \phi(n) $, which means $ ed-1 $ divides $ \phi(n) $ or $ ed-1 = k(p-1) = h(q-1) $ for some $ k, h $.

So, if we write our encrypted message using this exponent, we can see that $ m^{ed} $ is clearly just $ m $ \[m^{ed} = m^{ed-1}m = m^{k(p-1)}m = m^{(p-1)^k}m \] If we\textquotesingle{}re working mod $ p $, then we can write $ m^{(p-1)^k}m = m^{1^k}m = m^1m = m $. By a similar argument, the same applies to $ q $, so we can know that working mod $ pq = n $, the statement holds.

As stated above, the encryption exponent $ e $ and $ n $ make up the public key. The private key is made up of $ d $, the decryption exponenet and $ n $. It seems pretty obvious that the private key, $ p $, and $ q $ should be kept private; however, it is less obvious that $ \phi(n) $ should also remain private. This is because knowing $ \phi(n) $ is enough information to factor $ n $. Once that is done, $ d $ can be found.

Another less obvious note is that the messages encrypted using this method should not be Much Smaller than $ n $. If they are, then the cipher value is weak against a Low Exponent Attack, and may be decrypted by brute force.\hypertarget{rsa_messages_rsa}{}\subsection{Building Messages}\label{rsa_messages_rsa}
The math above shows that R\+SA can be used for messages which are large numbers. To send a string of text as a message, we must convert it into such a number. One option would be to determine the maximum number of bits that can be fit in n, take that many bits from the input, and use them as an integer; however, this can be difficult to work with if that number of bits is not an even number of bytes. This tool uses a different algorithm to generate messages.

Assuming that we are working with bytes of data, each byte will be in the range 0-\/255. If we take two bytes, a and b, and sum a$\ast$256 + b, we have a number that is unique to that string ab. It can also be decomposed to a and b by first taking doing an integer divison by 256 to get a and then modding it by 256 to get b. This tool uses a generalized version of this idea to encrypt any number of bytes into a large number. The number of bytes is determined to be the floor of log $_256$ of $ n $ + 1. This ensures that, by using successive powers of 256 to encrypt bytes, we can get a message close to $ n $ which can be decomposed back into the original string.\hypertarget{rsa_compile_rsa}{}\section{Compiling}\label{rsa_compile_rsa}
This tool can be built with the command \begin{DoxyVerb}make
\end{DoxyVerb}
 This will generate a release version of the tool in the release directory. To build a debug version in the debug directory, use the command \begin{DoxyVerb}make BUILD_TYPE=debug
\end{DoxyVerb}


This tool requires having G\+MP installed.\hypertarget{rsa_usage_rsa}{}\section{Usage}\label{rsa_usage_rsa}
This tool can be used to generate public and private key pairs, as well as encrypt and decrypt messages.

\begin{DoxyVerb}tool_rsa -g public private bits
tool_rsa -e/-d input output key
\end{DoxyVerb}
 Mode Options
\begin{DoxyItemize}
\item -\/g \+: To generate a public, private key pair. Specify output files for the public key and private key, as well as the number of bits n should contain
\item -\/e \+: To encrypt
\item -\/d \+: To decrypt
\end{DoxyItemize}

Input Options
\begin{DoxyItemize}
\item The input for encryption or decryption is a file name
\end{DoxyItemize}

Output Options
\begin{DoxyItemize}
\item The output for encryption or decryption is a file name
\end{DoxyItemize}

Key Options
\begin{DoxyItemize}
\item The key should be the file name of the key to use.
\end{DoxyItemize}

Keys should generally be larger than 2048 bits for security; 3072 bits if they will be used through the year 2030. Picking a number of bits less than 8 will fail because n must be at least 256 The key file for encryption should be a public key, and for decryption should the matching private key. 