\hypertarget{namespaceaffine}{}\section{affine Namespace Reference}
\label{namespaceaffine}\index{affine@{affine}}


Contains all library code for affine ciphers.  


\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classaffine_1_1transformer}{transformer}
\begin{DoxyCompactList}\small\item\em The affine transformer. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
const std\+::string \hyperlink{namespaceaffine_affbde77969645d73c99952c7f3259b83}{D\+E\+F\+A\+U\+L\+T\+\_\+\+A\+L\+P\+H\+A\+B\+ET} = \char`\"{}!@\#\$\%$^\wedge$\&$\ast$()\+\_\+-\/+=\{\}\mbox{[}$\,$\mbox{]}\+:;\textbackslash{}\char`\"{}\textbackslash{}\textquotesingle{}$<$$>$?,./`$\sim$$\vert$\textbackslash{}\textbackslash{} Aa\+Bb\+Cc\+Dd\+Ee\+Ff\+Gg\+Hh\+Ii\+Jj\+Kk\+Ll\+Mm\+Nn\+Oo\+Pp\+Qq\+Rr\+Ss\+Tt\+Uu\+Vv\+Ww\+Xx\+Yy\+Zz0123456789\char`\"{}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Contains all library code for affine ciphers. 

This includes only the affine cipher transformer type

Affine ciphers are a form of substitution cipher which takes the plaintext to a ciphertext using the transform $ c = \alpha m + \beta $ (mod $ n $) where
\begin{DoxyItemize}
\item $ c $ is the ciphertext
\item $ m $ is a character of the message
\item $ n $ is the size of the character set to use
\item $ \alpha $ is some value which is coprime with $ n $
\item $ \beta $ is any value (mod $ n $) Text is decrypted with the transform $ m = (c - \beta)\alpha^{-1} $ (mod $ n $) where $ \alpha^{-1} $ is the multiplicative inverse of $ \alpha $ mod $ n $
\end{DoxyItemize}

Characters are mapped to values mod $ n $ by their index in the alphabet. For example, if the alphabet is \textquotesingle{}abcde\textquotesingle{}, then
\begin{DoxyItemize}
\item $ n = $ 5
\item \textquotesingle{}a\textquotesingle{} maps to 0, \textquotesingle{}b\textquotesingle{} maps to 1... \textquotesingle{}e\textquotesingle{} maps to 4
\item All values except for 0 and multiples of 5 are valid for $ \alpha $ because 5 is prime
\end{DoxyItemize}

While this cipher is harder to crack than a simple shift cipher, it is still fairly trivial. If it is known what some plaintext values map to in the ciphertext, then a linear system of two variables can be solve mod $ n $ to yield $ \alpha, \beta $. If no mappings are known, a frequency analysis can be used to guess some. 

\subsection{Variable Documentation}
\index{affine@{affine}!D\+E\+F\+A\+U\+L\+T\+\_\+\+A\+L\+P\+H\+A\+B\+ET@{D\+E\+F\+A\+U\+L\+T\+\_\+\+A\+L\+P\+H\+A\+B\+ET}}
\index{D\+E\+F\+A\+U\+L\+T\+\_\+\+A\+L\+P\+H\+A\+B\+ET@{D\+E\+F\+A\+U\+L\+T\+\_\+\+A\+L\+P\+H\+A\+B\+ET}!affine@{affine}}
\subsubsection[{\texorpdfstring{D\+E\+F\+A\+U\+L\+T\+\_\+\+A\+L\+P\+H\+A\+B\+ET}{DEFAULT_ALPHABET}}]{\setlength{\rightskip}{0pt plus 5cm}const std\+::string affine\+::\+D\+E\+F\+A\+U\+L\+T\+\_\+\+A\+L\+P\+H\+A\+B\+ET = \char`\"{}!@\#\$\%$^\wedge$\&$\ast$()\+\_\+-\/+=\{\}\mbox{[}$\,$\mbox{]}\+:;\textbackslash{}\char`\"{}\textbackslash{}\textquotesingle{}$<$$>$?,./`$\sim$$\vert$\textbackslash{}\textbackslash{} Aa\+Bb\+Cc\+Dd\+Ee\+Ff\+Gg\+Hh\+Ii\+Jj\+Kk\+Ll\+Mm\+Nn\+Oo\+Pp\+Qq\+Rr\+Ss\+Tt\+Uu\+Vv\+Ww\+Xx\+Yy\+Zz0123456789\char`\"{}}\hypertarget{namespaceaffine_affbde77969645d73c99952c7f3259b83}{}\label{namespaceaffine_affbde77969645d73c99952c7f3259b83}
The default alphabet to use for affine transforms. It includes
\begin{DoxyItemize}
\item a-\/z
\item A-\/Z
\item 0-\/9
\item Most special characters 
\end{DoxyItemize}