<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Crypto Module: cryptomath Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Crypto Module
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cryptomath Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacecryptomath_1_1continuedfractions"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecryptomath_1_1continuedfractions.html">continuedfractions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecryptomath_1_1factoring"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecryptomath_1_1factoring.html">factoring</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecryptomath_1_1primality"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecryptomath_1_1primality.html">primality</a></td></tr>
<tr class="memdesc:namespacecryptomath_1_1primality"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains specific primality tests. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a66e56d7b478803e17352ef017eb1264b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66e56d7b478803e17352ef017eb1264b"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecryptomath.html#a66e56d7b478803e17352ef017eb1264b">Factor_Method</a> { <b>Fermat</b>, 
<b>PollardRho</b>, 
<b>Shanks</b>, 
<b>PollardP_1</b>
 }<tr class="memdesc:a66e56d7b478803e17352ef017eb1264b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum containing all factoring methods available. <br /></td></tr>
</td></tr>
<tr class="separator:a66e56d7b478803e17352ef017eb1264b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad814ed5cc6da07c16839c8ee79f0830d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad814ed5cc6da07c16839c8ee79f0830d"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecryptomath.html#ad814ed5cc6da07c16839c8ee79f0830d">Primality_Test</a> { <b>MillerRabin</b>, 
<b>SolovayStrassen</b>
 }<tr class="memdesc:ad814ed5cc6da07c16839c8ee79f0830d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum for available primality tests. <br /></td></tr>
</td></tr>
<tr class="separator:ad814ed5cc6da07c16839c8ee79f0830d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8efd5be118d0ab42b0c13ed237010f4d"><td class="memTemplParams" colspan="2">template&lt;class Integral &gt; </td></tr>
<tr class="memitem:a8efd5be118d0ab42b0c13ed237010f4d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Integral &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecryptomath.html#a8efd5be118d0ab42b0c13ed237010f4d">factor</a> (const Integral &amp;n, const <a class="el" href="namespacecryptomath.html#a66e56d7b478803e17352ef017eb1264b">Factor_Method</a> &amp;m=Factor_Method::PollardRho)</td></tr>
<tr class="memdesc:a8efd5be118d0ab42b0c13ed237010f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">General factoring algorithm.  <a href="#a8efd5be118d0ab42b0c13ed237010f4d">More...</a><br /></td></tr>
<tr class="separator:a8efd5be118d0ab42b0c13ed237010f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a47b8e8f73c44552d629e8b599df4a"><td class="memTemplParams" colspan="2">template&lt;class Integral &gt; </td></tr>
<tr class="memitem:a89a47b8e8f73c44552d629e8b599df4a"><td class="memTemplItemLeft" align="right" valign="top">Integral&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecryptomath.html#a89a47b8e8f73c44552d629e8b599df4a">phi</a> (Integral n)</td></tr>
<tr class="separator:a89a47b8e8f73c44552d629e8b599df4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4d38bdd977cca7686b73b516d1edde"><td class="memTemplParams" colspan="2">template&lt;class Integral &gt; </td></tr>
<tr class="memitem:ade4d38bdd977cca7686b73b516d1edde"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecryptomath.html#ade4d38bdd977cca7686b73b516d1edde">isPrimitiveRoot</a> (Integral a, const Integral &amp;n)</td></tr>
<tr class="memdesc:ade4d38bdd977cca7686b73b516d1edde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if some value is a primitive root.  <a href="#ade4d38bdd977cca7686b73b516d1edde">More...</a><br /></td></tr>
<tr class="separator:ade4d38bdd977cca7686b73b516d1edde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdfca9e5adf3b3660fcd8fcf94f116e6"><td class="memTemplParams" colspan="2">template&lt;class Integral &gt; </td></tr>
<tr class="memitem:abdfca9e5adf3b3660fcd8fcf94f116e6"><td class="memTemplItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecryptomath.html#abdfca9e5adf3b3660fcd8fcf94f116e6">mod2</a> (const Integral &amp;n)</td></tr>
<tr class="memdesc:abdfca9e5adf3b3660fcd8fcf94f116e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a value is odd.  <a href="#abdfca9e5adf3b3660fcd8fcf94f116e6">More...</a><br /></td></tr>
<tr class="separator:abdfca9e5adf3b3660fcd8fcf94f116e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e16705865a198f4d3b0227619a85596"><td class="memTemplParams" colspan="2">template&lt;class Integral &gt; </td></tr>
<tr class="memitem:a9e16705865a198f4d3b0227619a85596"><td class="memTemplItemLeft" align="right" valign="top">Integral&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecryptomath.html#a9e16705865a198f4d3b0227619a85596">sqrtfloor</a> (const Integral &amp;n)</td></tr>
<tr class="memdesc:a9e16705865a198f4d3b0227619a85596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Floor of square root.  <a href="#a9e16705865a198f4d3b0227619a85596">More...</a><br /></td></tr>
<tr class="separator:a9e16705865a198f4d3b0227619a85596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0bcf1b0015f3f35ed982614b9faee7e"><td class="memTemplParams" colspan="2">template&lt;class Integral &gt; </td></tr>
<tr class="memitem:ad0bcf1b0015f3f35ed982614b9faee7e"><td class="memTemplItemLeft" align="right" valign="top">Integral&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecryptomath.html#ad0bcf1b0015f3f35ed982614b9faee7e">powInt</a> (const Integral &amp;a, const Integral &amp;b)</td></tr>
<tr class="memdesc:ad0bcf1b0015f3f35ed982614b9faee7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer pow function.  <a href="#ad0bcf1b0015f3f35ed982614b9faee7e">More...</a><br /></td></tr>
<tr class="separator:ad0bcf1b0015f3f35ed982614b9faee7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72742b30d75eae62e700454832df24c6"><td class="memTemplParams" colspan="2">template&lt;class Integral &gt; </td></tr>
<tr class="memitem:a72742b30d75eae62e700454832df24c6"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecryptomath.html#a72742b30d75eae62e700454832df24c6">log2</a> (const Integral &amp;n)</td></tr>
<tr class="memdesc:a72742b30d75eae62e700454832df24c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log base 2.  <a href="#a72742b30d75eae62e700454832df24c6">More...</a><br /></td></tr>
<tr class="separator:a72742b30d75eae62e700454832df24c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad160be1fb9fce8cfb5862366d2298f13"><td class="memTemplParams" colspan="2">template&lt;class Integral &gt; </td></tr>
<tr class="memitem:ad160be1fb9fce8cfb5862366d2298f13"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecryptomath.html#ad160be1fb9fce8cfb5862366d2298f13">hasBits</a> (const uint64_t &amp;i)</td></tr>
<tr class="memdesc:ad160be1fb9fce8cfb5862366d2298f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if a type has a certain number of bits.  <a href="#ad160be1fb9fce8cfb5862366d2298f13">More...</a><br /></td></tr>
<tr class="separator:ad160be1fb9fce8cfb5862366d2298f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfbfbbf081ad84dfad43a2fa928d6bc8"><td class="memTemplParams" colspan="2">template&lt;class Integral &gt; </td></tr>
<tr class="memitem:abfbfbbf081ad84dfad43a2fa928d6bc8"><td class="memTemplItemLeft" align="right" valign="top">Integral&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecryptomath.html#abfbfbbf081ad84dfad43a2fa928d6bc8">abs</a> (const Integral &amp;a)</td></tr>
<tr class="memdesc:abfbfbbf081ad84dfad43a2fa928d6bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute value.  <a href="#abfbfbbf081ad84dfad43a2fa928d6bc8">More...</a><br /></td></tr>
<tr class="separator:abfbfbbf081ad84dfad43a2fa928d6bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f99173aeb277588bc453a6bb6dc8e0b"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a7f99173aeb277588bc453a6bb6dc8e0b"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecryptomath.html#a7f99173aeb277588bc453a6bb6dc8e0b">abs&lt; uint64_t &gt;</a> (const uint64_t &amp;a)</td></tr>
<tr class="memdesc:a7f99173aeb277588bc453a6bb6dc8e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute value.  <a href="#a7f99173aeb277588bc453a6bb6dc8e0b">More...</a><br /></td></tr>
<tr class="separator:a7f99173aeb277588bc453a6bb6dc8e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5d524cfbc767ac94668ea02f851d23"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a6c5d524cfbc767ac94668ea02f851d23"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecryptomath.html#a6c5d524cfbc767ac94668ea02f851d23">abs&lt; uint32_t &gt;</a> (const uint32_t &amp;a)</td></tr>
<tr class="memdesc:a6c5d524cfbc767ac94668ea02f851d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute value.  <a href="#a6c5d524cfbc767ac94668ea02f851d23">More...</a><br /></td></tr>
<tr class="separator:a6c5d524cfbc767ac94668ea02f851d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5431f9c91fc877731b94cc3a4496c10"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aa5431f9c91fc877731b94cc3a4496c10"><td class="memTemplItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecryptomath.html#aa5431f9c91fc877731b94cc3a4496c10">abs&lt; uint8_t &gt;</a> (const uint8_t &amp;a)</td></tr>
<tr class="memdesc:aa5431f9c91fc877731b94cc3a4496c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute value.  <a href="#aa5431f9c91fc877731b94cc3a4496c10">More...</a><br /></td></tr>
<tr class="separator:aa5431f9c91fc877731b94cc3a4496c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28abfc305f16df25575cba3bb3947bb8"><td class="memTemplParams" colspan="2">template&lt;class Integral &gt; </td></tr>
<tr class="memitem:a28abfc305f16df25575cba3bb3947bb8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecryptomath.html#a28abfc305f16df25575cba3bb3947bb8">isMaybeSquare</a> (const Integral &amp;n)</td></tr>
<tr class="memdesc:a28abfc305f16df25575cba3bb3947bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if it is possible that a number is square.  <a href="#a28abfc305f16df25575cba3bb3947bb8">More...</a><br /></td></tr>
<tr class="separator:a28abfc305f16df25575cba3bb3947bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d995827651201bac29716368c7e264b"><td class="memTemplParams" colspan="2">template&lt;class Integral &gt; </td></tr>
<tr class="memitem:a0d995827651201bac29716368c7e264b"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, Integral &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecryptomath.html#a0d995827651201bac29716368c7e264b">intSqrt</a> (const Integral &amp;n)</td></tr>
<tr class="memdesc:a0d995827651201bac29716368c7e264b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the square root of a square integer as an integer.  <a href="#a0d995827651201bac29716368c7e264b">More...</a><br /></td></tr>
<tr class="separator:a0d995827651201bac29716368c7e264b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f91eb84145b179dc7f377bbec75a95"><td class="memTemplParams" colspan="2">template&lt;class Integral &gt; </td></tr>
<tr class="memitem:ab3f91eb84145b179dc7f377bbec75a95"><td class="memTemplItemLeft" align="right" valign="top">Integral&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecryptomath.html#ab3f91eb84145b179dc7f377bbec75a95">mod</a> (const Integral &amp;a, const Integral &amp;b)</td></tr>
<tr class="memdesc:ab3f91eb84145b179dc7f377bbec75a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a (mod b), properly handling negative values.  <a href="#ab3f91eb84145b179dc7f377bbec75a95">More...</a><br /></td></tr>
<tr class="separator:ab3f91eb84145b179dc7f377bbec75a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aed65df4cc031c29146aebffc667c9c"><td class="memTemplParams" colspan="2">template&lt;class Integral &gt; </td></tr>
<tr class="memitem:a2aed65df4cc031c29146aebffc667c9c"><td class="memTemplItemLeft" align="right" valign="top">Integral&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecryptomath.html#a2aed65df4cc031c29146aebffc667c9c">_powMod</a> (Integral a, Integral b, const Integral &amp;n)</td></tr>
<tr class="separator:a2aed65df4cc031c29146aebffc667c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0fbf94961a03f0b41a4026bb2d71fe"><td class="memTemplParams" colspan="2">template&lt;class Integral &gt; </td></tr>
<tr class="memitem:a2d0fbf94961a03f0b41a4026bb2d71fe"><td class="memTemplItemLeft" align="right" valign="top">Integral&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecryptomath.html#a2d0fbf94961a03f0b41a4026bb2d71fe">powMod</a> (const Integral &amp;a, const Integral &amp;b, const Integral &amp;n)</td></tr>
<tr class="memdesc:a2d0fbf94961a03f0b41a4026bb2d71fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">PowMod wrapper to prevent overflow.  <a href="#a2d0fbf94961a03f0b41a4026bb2d71fe">More...</a><br /></td></tr>
<tr class="separator:a2d0fbf94961a03f0b41a4026bb2d71fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7628255f4415286878a8c12414fd5a5"><td class="memTemplParams" colspan="2">template&lt;class Integral &gt; </td></tr>
<tr class="memitem:af7628255f4415286878a8c12414fd5a5"><td class="memTemplItemLeft" align="right" valign="top">Integral&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecryptomath.html#af7628255f4415286878a8c12414fd5a5">_unsignedgcd</a> (const Integral &amp;a, const Integral &amp;b)</td></tr>
<tr class="memdesc:af7628255f4415286878a8c12414fd5a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursive gcd calculation that assumes a, b unsigned.  <a href="#af7628255f4415286878a8c12414fd5a5">More...</a><br /></td></tr>
<tr class="separator:af7628255f4415286878a8c12414fd5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa611c2ae215df44cc0b7d967642ce252"><td class="memTemplParams" colspan="2">template&lt;class Integral &gt; </td></tr>
<tr class="memitem:aa611c2ae215df44cc0b7d967642ce252"><td class="memTemplItemLeft" align="right" valign="top">Integral&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecryptomath.html#aa611c2ae215df44cc0b7d967642ce252">gcd</a> (Integral a, Integral b)</td></tr>
<tr class="memdesc:aa611c2ae215df44cc0b7d967642ce252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes gcd(|a|, |b|).  <a href="#aa611c2ae215df44cc0b7d967642ce252">More...</a><br /></td></tr>
<tr class="separator:aa611c2ae215df44cc0b7d967642ce252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade73e96f11f5b082fda92068b63e07e4"><td class="memTemplParams" colspan="2">template&lt;class Integral &gt; </td></tr>
<tr class="memitem:ade73e96f11f5b082fda92068b63e07e4"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; Integral, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecryptomath.html#ade73e96f11f5b082fda92068b63e07e4">extendedGcd</a> (Integral a_, Integral b_)</td></tr>
<tr class="memdesc:ade73e96f11f5b082fda92068b63e07e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the extended gcd of a, b.  <a href="#ade73e96f11f5b082fda92068b63e07e4">More...</a><br /></td></tr>
<tr class="separator:ade73e96f11f5b082fda92068b63e07e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3016a6b389d67dbc28682a48776df32a"><td class="memTemplParams" colspan="2">template&lt;class Integral &gt; </td></tr>
<tr class="memitem:a3016a6b389d67dbc28682a48776df32a"><td class="memTemplItemLeft" align="right" valign="top">Integral&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecryptomath.html#a3016a6b389d67dbc28682a48776df32a">inverseMod</a> (const Integral &amp;a, const Integral &amp;n)</td></tr>
<tr class="memdesc:a3016a6b389d67dbc28682a48776df32a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds \( a^{-1} \) mod \( n \).  <a href="#a3016a6b389d67dbc28682a48776df32a">More...</a><br /></td></tr>
<tr class="separator:a3016a6b389d67dbc28682a48776df32a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79615d1b307a407ebe932c452279682"><td class="memTemplParams" colspan="2">template&lt;class Integral &gt; </td></tr>
<tr class="memitem:ae79615d1b307a407ebe932c452279682"><td class="memTemplItemLeft" align="right" valign="top">Integral&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecryptomath.html#ae79615d1b307a407ebe932c452279682">legendre</a> (const Integral &amp;a, const Integral &amp;p)</td></tr>
<tr class="memdesc:ae79615d1b307a407ebe932c452279682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Legendre symbol.  <a href="#ae79615d1b307a407ebe932c452279682">More...</a><br /></td></tr>
<tr class="separator:ae79615d1b307a407ebe932c452279682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c17a71b0bde52c2e11acefc3975210f"><td class="memTemplParams" colspan="2">template&lt;class Integral &gt; </td></tr>
<tr class="memitem:a4c17a71b0bde52c2e11acefc3975210f"><td class="memTemplItemLeft" align="right" valign="top">Integral&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecryptomath.html#a4c17a71b0bde52c2e11acefc3975210f">_jacobi</a> (Integral a, Integral n)</td></tr>
<tr class="memdesc:a4c17a71b0bde52c2e11acefc3975210f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the jacobi symbol.  <a href="#a4c17a71b0bde52c2e11acefc3975210f">More...</a><br /></td></tr>
<tr class="separator:a4c17a71b0bde52c2e11acefc3975210f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf6fff4156956c6cd1c684cf2d68476"><td class="memTemplParams" colspan="2">template&lt;class Integral &gt; </td></tr>
<tr class="memitem:aeaf6fff4156956c6cd1c684cf2d68476"><td class="memTemplItemLeft" align="right" valign="top">Integral&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecryptomath.html#aeaf6fff4156956c6cd1c684cf2d68476">jacobi</a> (const Integral &amp;a, const Integral &amp;n)</td></tr>
<tr class="memdesc:aeaf6fff4156956c6cd1c684cf2d68476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Jacobi symbol wrapper to guarantee that the type is signed.  <a href="#aeaf6fff4156956c6cd1c684cf2d68476">More...</a><br /></td></tr>
<tr class="separator:aeaf6fff4156956c6cd1c684cf2d68476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36ab56ab6b7f4626fb3ab5840fd67f1"><td class="memTemplParams" colspan="2">template&lt;class Integral &gt; </td></tr>
<tr class="memitem:ad36ab56ab6b7f4626fb3ab5840fd67f1"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; Integral, Integral &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecryptomath.html#ad36ab56ab6b7f4626fb3ab5840fd67f1">factor2s</a> (const Integral &amp;n)</td></tr>
<tr class="memdesc:ad36ab56ab6b7f4626fb3ab5840fd67f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factors all powers of 2 out of a number.  <a href="#ad36ab56ab6b7f4626fb3ab5840fd67f1">More...</a><br /></td></tr>
<tr class="separator:ad36ab56ab6b7f4626fb3ab5840fd67f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6964cc63e189eadb8c74202df0fd0040"><td class="memTemplParams" colspan="2">template&lt;class Integral &gt; </td></tr>
<tr class="memitem:a6964cc63e189eadb8c74202df0fd0040"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecryptomath.html#a6964cc63e189eadb8c74202df0fd0040">sundaramSieve</a> (const Integral &amp;n, std::vector&lt; Integral &gt; &amp;result)</td></tr>
<tr class="memdesc:a6964cc63e189eadb8c74202df0fd0040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sundaram's sieve for finding prime numbers.  <a href="#a6964cc63e189eadb8c74202df0fd0040">More...</a><br /></td></tr>
<tr class="separator:a6964cc63e189eadb8c74202df0fd0040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf75dafaf0743a34c20ca949abd858cf"><td class="memTemplParams" colspan="2">template&lt;class Integral &gt; </td></tr>
<tr class="memitem:abf75dafaf0743a34c20ca949abd858cf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecryptomath.html#abf75dafaf0743a34c20ca949abd858cf">isPrime</a> (const Integral &amp;n, const <a class="el" href="namespacecryptomath.html#ad814ed5cc6da07c16839c8ee79f0830d">Primality_Test</a> &amp;test=Primality_Test::MillerRabin, const uint64_t &amp;iterations=20)</td></tr>
<tr class="separator:abf75dafaf0743a34c20ca949abd858cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50fd8408608cf109b166fbc13268cbd0"><td class="memTemplParams" colspan="2">template&lt;class Integral &gt; </td></tr>
<tr class="memitem:a50fd8408608cf109b166fbc13268cbd0"><td class="memTemplItemLeft" align="right" valign="top">Integral&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecryptomath.html#a50fd8408608cf109b166fbc13268cbd0">nextPrime</a> (Integral start, const uint64_t &amp;reps=20)</td></tr>
<tr class="memdesc:a50fd8408608cf109b166fbc13268cbd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first prime greater than some number.  <a href="#a50fd8408608cf109b166fbc13268cbd0">More...</a><br /></td></tr>
<tr class="separator:a50fd8408608cf109b166fbc13268cbd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01547d5de9fda1bcfb783be02d512d06"><td class="memTemplParams" colspan="2">template&lt;class Integral , class UniformRandomBitGenerator &gt; </td></tr>
<tr class="memitem:a01547d5de9fda1bcfb783be02d512d06"><td class="memTemplItemLeft" align="right" valign="top">Integral&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecryptomath.html#a01547d5de9fda1bcfb783be02d512d06">_randomPrime</a> (UniformRandomBitGenerator &amp;bits, const uint64_t &amp;bitcount, const uint64_t &amp;prime_reps=20)</td></tr>
<tr class="memdesc:a01547d5de9fda1bcfb783be02d512d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random prime with a specific number of bits.  <a href="#a01547d5de9fda1bcfb783be02d512d06">More...</a><br /></td></tr>
<tr class="separator:a01547d5de9fda1bcfb783be02d512d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f24268856fbd366cb688640736fb60"><td class="memTemplParams" colspan="2">template&lt;class Integral , class UniformRandomBitGenerator &gt; </td></tr>
<tr class="memitem:a93f24268856fbd366cb688640736fb60"><td class="memTemplItemLeft" align="right" valign="top">Integral&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecryptomath.html#a93f24268856fbd366cb688640736fb60">randomPrime</a> (UniformRandomBitGenerator &amp;bits, const uint64_t &amp;bitcount, const uint64_t &amp;prime_reps=20)</td></tr>
<tr class="memdesc:a93f24268856fbd366cb688640736fb60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for _randomPrime that verifies that the output type can hold the prime without overflow.  <a href="#a93f24268856fbd366cb688640736fb60">More...</a><br /></td></tr>
<tr class="separator:a93f24268856fbd366cb688640736fb60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4ea3d67f0fc08b698da0b718244b4f"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aea4ea3d67f0fc08b698da0b718244b4f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecryptomath.html#aea4ea3d67f0fc08b698da0b718244b4f">hasBits&lt; mpz_class &gt;</a> (const uint64_t &amp;i)</td></tr>
<tr class="separator:aea4ea3d67f0fc08b698da0b718244b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace84983f1bbb2211b1fba2c6a606c678"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ace84983f1bbb2211b1fba2c6a606c678"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecryptomath.html#ace84983f1bbb2211b1fba2c6a606c678">log2&lt; mpz_class &gt;</a> (const mpz_class &amp;n)</td></tr>
<tr class="separator:ace84983f1bbb2211b1fba2c6a606c678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfcd8397f758faec532f382662223fb6"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:abfcd8397f758faec532f382662223fb6"><td class="memTemplItemLeft" align="right" valign="top">mpz_class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecryptomath.html#abfcd8397f758faec532f382662223fb6">sqrtfloor&lt; mpz_class &gt;</a> (const mpz_class &amp;n)</td></tr>
<tr class="separator:abfcd8397f758faec532f382662223fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ebe48f61ac75ba4a1cda2ef1fd168c"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a44ebe48f61ac75ba4a1cda2ef1fd168c"><td class="memTemplItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecryptomath.html#a44ebe48f61ac75ba4a1cda2ef1fd168c">mod2&lt; mpz_class &gt;</a> (const mpz_class &amp;n)</td></tr>
<tr class="separator:a44ebe48f61ac75ba4a1cda2ef1fd168c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482b681cd134f41c52e4801ee0f61de2"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a482b681cd134f41c52e4801ee0f61de2"><td class="memTemplItemLeft" align="right" valign="top">mpz_class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecryptomath.html#a482b681cd134f41c52e4801ee0f61de2">powMod&lt; mpz_class &gt;</a> (const mpz_class &amp;a, const mpz_class &amp;b, const mpz_class &amp;n)</td></tr>
<tr class="separator:a482b681cd134f41c52e4801ee0f61de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b55922895218d613733ea0370e8e5f"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a47b55922895218d613733ea0370e8e5f"><td class="memTemplItemLeft" align="right" valign="top">mpz_class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecryptomath.html#a47b55922895218d613733ea0370e8e5f">jacobi&lt; mpz_class &gt;</a> (const mpz_class &amp;a, const mpz_class &amp;n)</td></tr>
<tr class="separator:a47b55922895218d613733ea0370e8e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains a variety of functions used in cryptography and modular arithmetic. As well as some template specializations to make most of the functions compatible with the GNU Multiprecision library (GMP)</p>
<p>file </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a4c17a71b0bde52c2e11acefc3975210f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Integral &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Integral cryptomath::_jacobi </td>
          <td>(</td>
          <td class="paramtype">Integral&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integral&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the jacobi symbol. </p>
<p>This function should not be called directly. Call the wrapper <a class="el" href="namespacecryptomath.html#aeaf6fff4156956c6cd1c684cf2d68476" title="Jacobi symbol wrapper to guarantee that the type is signed. ">jacobi()</a> to prevent type issues</p>
<p>The Jacobi symbol \( (\frac{a}{n}) \) is a generalization of the Legendre symbol to all odd integers. One way to compute it is to find the product of the Legendre symbols for all prime factors of \( n \). This specific implementation uses the law of Quadratic Reciprocity to calculate the Jacobi without factoring \( n \). More details on the algorithm can be found at <a href="http://2000clicks.com/mathhelp/NumberTh27JacobiSymbolAlgorithm.aspx">http://2000clicks.com/mathhelp/NumberTh27JacobiSymbolAlgorithm.aspx</a></p>
<p>Template arguments</p><ul>
<li>class Integral - Some signed integer type</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>- Some odd integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integral - \( (\frac{a}{n}) \) </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">logic_error</td><td>: n is negative or even </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2aed65df4cc031c29146aebffc667c9c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Integral &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Integral cryptomath::_powMod </td>
          <td>(</td>
          <td class="paramtype">Integral&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integral&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integral &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes \( a^b\) mod \( n \)</p>
<p>Fast power mod function taken from Applied Cryptography by Bruce Schneier. It makes use of the powers of two present in \( b \) to compute the result.</p>
<p>Template arguments</p><ul>
<li>class Integral - Some integer type</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integral - \( a^b\) mod \( n \) </dd></dl>

</div>
</div>
<a class="anchor" id="a01547d5de9fda1bcfb783be02d512d06"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Integral , class UniformRandomBitGenerator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Integral cryptomath::_randomPrime </td>
          <td>(</td>
          <td class="paramtype">UniformRandomBitGenerator &amp;&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>bitcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>prime_reps</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a random prime with a specific number of bits. </p>
<p>This function should not be called directly; use <a class="el" href="namespacecryptomath.html#a93f24268856fbd366cb688640736fb60" title="Wrapper for _randomPrime that verifies that the output type can hold the prime without overflow...">randomPrime()</a> in order to guaranteed that the output value will fit in the templated type</p>
<p>It is often useful to have a random prime of a specific number of bits. This function generates a random number with the specified number of bits, and then finds the first prime larger than that. If that prime has too many bits, it is divided in half and the first prime greater than that is used. The Miller-Rabin primality test is used to find the first bigger prime.</p>
<p>Template arguments</p><ul>
<li>class Integral - Some integer type</li>
<li>class UniformRandomBitGenerator - Some type meeting the C++ UniformRandomBitGenerator specification</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bits</td><td>- A random bit generator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bitcount</td><td>- Number of bits in final value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prime_reps</td><td>- Number of iterations to do probabalistic primality test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integral - A random prime with the specified number of bits </dd></dl>

</div>
</div>
<a class="anchor" id="af7628255f4415286878a8c12414fd5a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Integral &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Integral cryptomath::_unsignedgcd </td>
          <td>(</td>
          <td class="paramtype">const Integral &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integral &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursive gcd calculation that assumes a, b unsigned. </p>
<p>For general use, call <a class="el" href="namespacecryptomath.html#aa611c2ae215df44cc0b7d967642ce252" title="Computes gcd(|a|, |b|). ">gcd</a></p>
<p>Uses the Euclidian gcd formula. If a % b is non-0, then the solution is the same as gcd(b, a % b)</p>
<p>Template arguments</p><ul>
<li>class Integral - Some integer type</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integral - gcd(a, b) </dd></dl>

</div>
</div>
<a class="anchor" id="abfbfbbf081ad84dfad43a2fa928d6bc8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Integral &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Integral cryptomath::abs </td>
          <td>(</td>
          <td class="paramtype">const Integral &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Absolute value. </p>
<p>Templated absolute value function which can be specialized for non standard integer types</p>
<p>Template arguments</p><ul>
<li>class Integral - Some integer type</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Value to absolute </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integral - |a| </dd></dl>

</div>
</div>
<a class="anchor" id="a6c5d524cfbc767ac94668ea02f851d23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="namespacecryptomath.html#abfbfbbf081ad84dfad43a2fa928d6bc8">cryptomath::abs</a>&lt; uint32_t &gt; </td>
          <td>(</td>
          <td class="paramtype">const uint32_t &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Absolute value. </p>
<p>Specialization of abs for unsigned 32 bit int so that other functions which need an absolute value can work with unsigned values</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Value to absolute </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t - |a| </dd></dl>

</div>
</div>
<a class="anchor" id="a7f99173aeb277588bc453a6bb6dc8e0b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="namespacecryptomath.html#abfbfbbf081ad84dfad43a2fa928d6bc8">cryptomath::abs</a>&lt; uint64_t &gt; </td>
          <td>(</td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Absolute value. </p>
<p>Specialization of abs for unsigned 64 bit int so that other functions which need an absolute value can work with unsigned values</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Value to absolute </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint64_t - |a| </dd></dl>

</div>
</div>
<a class="anchor" id="aa5431f9c91fc877731b94cc3a4496c10"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="namespacecryptomath.html#abfbfbbf081ad84dfad43a2fa928d6bc8">cryptomath::abs</a>&lt; uint8_t &gt; </td>
          <td>(</td>
          <td class="paramtype">const uint8_t &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Absolute value. </p>
<p>Specialization of abs for unsigned 8 bit int so that other functions which need an absolute value can work with unsigned values</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Value to absolute </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint8_t - |a| </dd></dl>

</div>
</div>
<a class="anchor" id="ade73e96f11f5b082fda92068b63e07e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Integral &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;Integral, 3&gt; cryptomath::extendedGcd </td>
          <td>(</td>
          <td class="paramtype">Integral&#160;</td>
          <td class="paramname"><em>a_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integral&#160;</td>
          <td class="paramname"><em>b_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the extended gcd of a, b. </p>
<p>Finds a solution for a*x + b*y = gcd(|a|, |b|) using the extended Euclidian gcd. For each iteration until a % b = 0</p><ul>
<li>\( q(i) = a/b \)</li>
<li>\( x(i) = -q(i)*x(i-1) + x(i-2)\)</li>
<li>\( y(i) = -q(i)*y(i-1) + y(i-2) \)</li>
<li>\( b, a = a%b, b \)</li>
</ul>
<p>Template arguments</p><ul>
<li>class Integral - Some integer type</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b_</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array&lt;Integral, 3&gt; - [gcd(|a|, |b|), x, y] </dd></dl>

</div>
</div>
<a class="anchor" id="a8efd5be118d0ab42b0c13ed237010f4d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Integral &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Integral&gt; cryptomath::factor </td>
          <td>(</td>
          <td class="paramtype">const Integral &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecryptomath.html#a66e56d7b478803e17352ef017eb1264b">Factor_Method</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em> = <code>Factor_Method::PollardRho</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>General factoring algorithm. </p>
<p>This function will use one of the specific factoring functions in the factoring namespace to find all prime factors of a number. It factors out all powers of 2, and checks for primality; while factors are not prime, they are factored using the specified algorithm.</p>
<p>Template arguments</p><ul>
<li>class Integral - Some Integer type</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The value to factor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The method of factorization to use (Default Pollard's Rho algorithm) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;Integral, Integral&gt; - All prime factors of \( n \) sorted from smallest to largest. If \( n \) is prime, it contains only \( n \). Factors which are used multiple times are included multiple times </dd></dl>

</div>
</div>
<a class="anchor" id="ad36ab56ab6b7f4626fb3ab5840fd67f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Integral &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;Integral, Integral&gt; cryptomath::factor2s </td>
          <td>(</td>
          <td class="paramtype">const Integral &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factors all powers of 2 out of a number. </p>
<p>Many factoring and primality tests only work with odd integers. This function divides all powers of two out of a number</p>
<p>Template arguments</p><ul>
<li>class Integral - Some integer type</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>- The number to factor 2's from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair&lt;Integral, Integral&gt; - [number of 2's factored out, n with all powers of 2 factored out] </dd></dl>

</div>
</div>
<a class="anchor" id="aa611c2ae215df44cc0b7d967642ce252"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Integral &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Integral cryptomath::gcd </td>
          <td>(</td>
          <td class="paramtype">Integral&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integral&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes gcd(|a|, |b|). </p>
<p>If a or b is 0, the other is returned. gcd(0, 0) returns 0.</p>
<p>Template arguments</p><ul>
<li>class Integral - Some integer type</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integral - gcd(|a|, |b|) </dd></dl>

</div>
</div>
<a class="anchor" id="ad160be1fb9fce8cfb5862366d2298f13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Integral &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cryptomath::hasBits </td>
          <td>(</td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests if a type has a certain number of bits. </p>
<p>Can be specialized for arbitrary precision types to always return true</p>
<p>Template arguments</p><ul>
<li>class Integral - Some integer type</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Number of bits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool - Whether or not Integral type has at least i bits </dd></dl>

</div>
</div>
<a class="anchor" id="aea4ea3d67f0fc08b698da0b718244b4f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacecryptomath.html#ad160be1fb9fce8cfb5862366d2298f13">cryptomath::hasBits</a>&lt; mpz_class &gt; </td>
          <td>(</td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Template specialization of <a class="el" href="namespacecryptomath.html#ad160be1fb9fce8cfb5862366d2298f13" title="Tests if a type has a certain number of bits. ">hasBits()</a> for mpz_class</p>
<p>Always returns true because mpz_class type has an unlimited number of bits</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>- Number of bits needed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool - true </dd></dl>

</div>
</div>
<a class="anchor" id="a0d995827651201bac29716368c7e264b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Integral &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, Integral&gt; cryptomath::intSqrt </td>
          <td>(</td>
          <td class="paramtype">const Integral &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the square root of a square integer as an integer. </p>
<p>Utilizes the isMaybeSquare function to quickly rule out some numbers as being square. If the number might be square, it is checked by computing the square of the floor of its square root.</p>
<p>Template arguments</p><ul>
<li>class Integral - Some integer type</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number to square root </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair&lt;bool, Integral&gt; - [false, 0] if n not square, [true, sqrt(n)] if it is </dd></dl>

</div>
</div>
<a class="anchor" id="a3016a6b389d67dbc28682a48776df32a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Integral &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Integral cryptomath::inverseMod </td>
          <td>(</td>
          <td class="paramtype">const Integral &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integral &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds \( a^{-1} \) mod \( n \). </p>
<p>Finds the modular inverse of a (mod n). That is, finds x such that \( a*x = 1 \) mod \( n \). Using the extended gcd of a and n, if a and n are relatively prime, then the solution is x (mod n) from the equation \( ax + ny = 1 \)</p>
<p>Template arguments</p><ul>
<li>class Integral - Some integer type</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integral - \( a^{-1} \) mod \( n \) (0 if non-existant) </dd></dl>

</div>
</div>
<a class="anchor" id="a28abfc305f16df25575cba3bb3947bb8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Integral &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cryptomath::isMaybeSquare </td>
          <td>(</td>
          <td class="paramtype">const Integral &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if it is possible that a number is square. </p>
<p>It can be show that any perfect square must be of one of the following forms: 00, e1, e4, 25, o6, e9 where e is any even digit and o is any odd digit. Using this rule, we can rule out some numbers as perfect squares quickly.</p>
<p>Proof:</p>
<p>Any number can be written in the form \( 100a + 10b + c \) where \( b, c \) are the last two digits of the number and \( a \) is the rest of the digits. If we square this, we obtain </p><p class="formulaDsp">
\[10000a^2 + 2000ab + 200ac + 100b^2 + 20bc + c^2 \]
</p>
<p> The first four terms are guaranteed to be greater than 100, so we care about \(20bc + c^2 \). Notice that \( 20bc \) is guaranteed to contribute an even amount to the 10's place. If we write out all possible values for \( c^2 \), we can see that all the of listed forms except 00 and 25 are accounted for. The only case to end with 0 is when \( c=0 \), so therefore \( 20bc = 0\), which means 00 is a valid form. The only way to end with 5 is when \( c = 5 \). In this case, \( 20bc \) becomes \( 100b \) and therefore does not contribute to the last two digits; so we are left with \( c^2 = 25 \) asthe last two digits</p>
<p>Template arguments</p><ul>
<li>class Integral - Some integer type</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number to check for possible squareness </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool - Whether or not it's possible that n is square </dd></dl>

</div>
</div>
<a class="anchor" id="abf75dafaf0743a34c20ca949abd858cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Integral &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cryptomath::isPrime </td>
          <td>(</td>
          <td class="paramtype">const Integral &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecryptomath.html#ad814ed5cc6da07c16839c8ee79f0830d">Primality_Test</a> &amp;&#160;</td>
          <td class="paramname"><em>test</em> = <code>Primality_Test::MillerRabin</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>iterations</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>General prime test</p>
<p>This prime test function uses one of the prime tests in the primality namespace to check if a number is prime. A couple of trivial cases are checked for first; anything less than 3 or even is hard-coded.</p>
<p>Template arguments</p><ul>
<li>class Integral - Some integer type</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number to test for primality </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">test</td><td>Which primality test to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iterations</td><td>Number of iterations to do the probabalistic test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool - Whether or not \( n \) is probably prime </dd></dl>

</div>
</div>
<a class="anchor" id="ade4d38bdd977cca7686b73b516d1edde"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Integral &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cryptomath::isPrimitiveRoot </td>
          <td>(</td>
          <td class="paramtype">Integral&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integral &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if some value is a primitive root. </p>
<p>A primitive root \( x \) mod \( n \) is any value for which all values coprime to \( n \) can be found as some \( x^k \) mod \( n \) for some \( k \). If \( n \) is prime, then all primitive roots of it are generators of the set \( Z_n \). For any primitive root, its order (number of successive powers before repeat) is \( \phi(n) \)</p>
<p>We can check if some \( a \) is a primitive root mod \( n \) with a couple of rules</p><ul>
<li>For some prime \( p \), a primitive root will satisfy \( a^{\phi(p)/q_i} \neq 1 \) mod \( p \) for all factors \( q_i \) of \( \phi(p) \)</li>
<li>Other than 1, 2, and 4, numbers with primitive roots are of the form \( p^k \) or \( 2p^k \) for some odd prime \( p \)</li>
<li>The order of a primitive root mod \( n \) is \( \phi(n) \)</li>
<li>If \( a \) is a primitive root of \( p \), then either \( a \) or \( a + p \) is a primitive root of all \( p^k \)</li>
<li>If some odd \( a \) is a primitive root of \( p \), then \( a \) is a primitive root of all \( 2p^k \)</li>
</ul>
<p>So, to check if \( a \) is a primitive root mod \( n \), we first check that \( n \) is of the form of a number with primitive roots. Then we factor \( n \) to get it's prime factor. We check if \( a \) is a primitive root of that prime factor. If that prime factor is the only factor then \( n \) is prime and we are done. Otherwise, we check if the order of \( a \) is \( \phi(n) \) mod \( p^2 \). If 2 is not a factor of \( n \), then we are done; otherwise, we check if \( a \) is odd.</p>
<p>Template arguments</p><ul>
<li>class Integral - Some integer value</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The number to test if it's a primitive root </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number to test \( a \) modded by </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool - Whether or not \( a \) is a primitive root mod \( n \) </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">logic_error</td><td>: powmod would overflow the Integral type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeaf6fff4156956c6cd1c684cf2d68476"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Integral &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Integral cryptomath::jacobi </td>
          <td>(</td>
          <td class="paramtype">const Integral &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integral &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Jacobi symbol wrapper to guarantee that the type is signed. </p>
<p>The recursive Jacobi function requires signed values. This wrapper throws an exception if the template type is strictly unsigned. Specialize this for any type which cannot be checked with std::is_unsigned</p>
<p>Template arguments</p><ul>
<li>class Integral - Some integral type</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>- Some odd integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integral - \( (\frac{a}{n}) \) </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">logic_error</td><td>: Integral is an unsigned type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a47b55922895218d613733ea0370e8e5f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mpz_class <a class="el" href="namespacecryptomath.html#aeaf6fff4156956c6cd1c684cf2d68476">cryptomath::jacobi</a>&lt; mpz_class &gt; </td>
          <td>(</td>
          <td class="paramtype">const mpz_class &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mpz_class &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Template specialization of <a class="el" href="namespacecryptomath.html#aeaf6fff4156956c6cd1c684cf2d68476" title="Jacobi symbol wrapper to guarantee that the type is signed. ">jacobi()</a> for mpz_class</p>
<p>The <a class="el" href="namespacecryptomath.html#aeaf6fff4156956c6cd1c684cf2d68476" title="Jacobi symbol wrapper to guarantee that the type is signed. ">jacobi()</a> function tests that the result type is not unsigned. There is no unsigned mpz_class type, so this check is removed</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>- Some odd integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integral - \( (\frac{a}{n}) \) </dd></dl>

</div>
</div>
<a class="anchor" id="ae79615d1b307a407ebe932c452279682"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Integral &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Integral cryptomath::legendre </td>
          <td>(</td>
          <td class="paramtype">const Integral &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integral &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Legendre symbol. </p>
<p>The Legendre symbol \( (\frac{a}{p}) \) is defined as \( a^{(p-1)/2} \) mod \( p \) for prime values \( p \)</p>
<p>Template arguments</p><ul>
<li>class Integral - Some integer type</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A prime number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integral - \( (\frac{a}{p}) \) </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">logic_error</td><td>: powmod would overflow the Integral type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a72742b30d75eae62e700454832df24c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Integral &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint64_t cryptomath::log2 </td>
          <td>(</td>
          <td class="paramtype">const Integral &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Log base 2. </p>
<p>Template arguments</p><ul>
<li>class Integral - Some integer type</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Value to square root </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integral -Square root of n rounded down </dd></dl>

</div>
</div>
<a class="anchor" id="ace84983f1bbb2211b1fba2c6a606c678"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="namespacecryptomath.html#a72742b30d75eae62e700454832df24c6">cryptomath::log2</a>&lt; mpz_class &gt; </td>
          <td>(</td>
          <td class="paramtype">const mpz_class &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Template specialization of <a class="el" href="namespacecryptomath.html#a72742b30d75eae62e700454832df24c6" title="Log base 2. ">log2()</a> for mpz_class</p>
<p>Returns log base 2 of the number. No log function exists in the GMP library, so the number of bits required to represent the number is used instead</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>- Number to take log2 of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint64_t - Number of bits needed to represent n </dd></dl>

</div>
</div>
<a class="anchor" id="ab3f91eb84145b179dc7f377bbec75a95"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Integral &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Integral cryptomath::mod </td>
          <td>(</td>
          <td class="paramtype">const Integral &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integral &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a (mod b), properly handling negative values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The top of the rational to convert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The bottom of the rational to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integral - a (mod b) </dd></dl>

</div>
</div>
<a class="anchor" id="abdfca9e5adf3b3660fcd8fcf94f116e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Integral &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint8_t cryptomath::mod2 </td>
          <td>(</td>
          <td class="paramtype">const Integral &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a value is odd. </p>
<p>Standard templated call for checking if a value is odd. This exists because it is often faster to test the least significant bit than to call a modulus operator, and the bitwise operators are not standard for GMP. For any integer type that doesn't implement bitwise operators, this can be specialized to provide an efficient odd test.</p>
<p>Template arguments</p><ul>
<li>class Integral - Some integer type</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Value to test for odd-ness </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint8_t - n % 2 </dd></dl>

</div>
</div>
<a class="anchor" id="a44ebe48f61ac75ba4a1cda2ef1fd168c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="namespacecryptomath.html#abdfca9e5adf3b3660fcd8fcf94f116e6">cryptomath::mod2</a>&lt; mpz_class &gt; </td>
          <td>(</td>
          <td class="paramtype">const mpz_class &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Template specialization of <a class="el" href="namespacecryptomath.html#abdfca9e5adf3b3660fcd8fcf94f116e6" title="Checks if a value is odd. ">mod2()</a> for mpz_class</p>
<p>GMP class types do not support binary operators, but the easiest way to mod 2 is by checking the LSB. This is done with the special function GMP provides for that</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>- The number to mod by 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint8_t - n modded by 2 </dd></dl>

</div>
</div>
<a class="anchor" id="a50fd8408608cf109b166fbc13268cbd0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Integral &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Integral cryptomath::nextPrime </td>
          <td>(</td>
          <td class="paramtype">Integral&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>reps</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first prime greater than some number. </p>
<p>The next prime is found by testing sequential odd numbers for primality until one is found to be prime using the Miller-Rabin test</p>
<p>Template arguments Integral - Some integer type</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>- The number to start at </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reps</td><td>- Number of iterations to do the probabalistic prime test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integral - The first prime greater than the starting value </dd></dl>

</div>
</div>
<a class="anchor" id="a89a47b8e8f73c44552d629e8b599df4a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Integral &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Integral cryptomath::phi </td>
          <td>(</td>
          <td class="paramtype">Integral&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates \( \phi(n) \)</p>
<p>This function calculates Euler's totient function for any value using only integer math.</p>
<p>Template arguments</p><ul>
<li>class Integral - Some integer type <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number to find the totient of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integral - \( \phi(n) \) </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ad0bcf1b0015f3f35ed982614b9faee7e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Integral &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Integral cryptomath::powInt </td>
          <td>(</td>
          <td class="paramtype">const Integral &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integral &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integer pow function. </p>
<p>Template arguments</p><ul>
<li>class Integral - Some integer type</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Base </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Power to take a to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integral - a^b </dd></dl>

</div>
</div>
<a class="anchor" id="a2d0fbf94961a03f0b41a4026bb2d71fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Integral &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Integral cryptomath::powMod </td>
          <td>(</td>
          <td class="paramtype">const Integral &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integral &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Integral &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PowMod wrapper to prevent overflow. </p>
<p>If n-1 is greater than the square root of the maximum value of Integral, then the _powMod function will overflow the type. This wrapper throws an exception if that is the case. Specialize this template for any type which cannot be used with std::numeric_limits.</p>
<p>Template arguments</p><ul>
<li>class Integral - Some integer type</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integral - \( a^b\) mod \( n \) </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">logic_error</td><td>: Computing the power mod n would overflow type Integral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a482b681cd134f41c52e4801ee0f61de2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mpz_class <a class="el" href="namespacecryptomath.html#a2d0fbf94961a03f0b41a4026bb2d71fe">cryptomath::powMod</a>&lt; mpz_class &gt; </td>
          <td>(</td>
          <td class="paramtype">const mpz_class &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mpz_class &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mpz_class &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Template specialization of <a class="el" href="namespacecryptomath.html#a2d0fbf94961a03f0b41a4026bb2d71fe" title="PowMod wrapper to prevent overflow. ">powMod()</a> for mpz_class</p>
<p>The <a class="el" href="namespacecryptomath.html#a2d0fbf94961a03f0b41a4026bb2d71fe" title="PowMod wrapper to prevent overflow. ">powMod()</a> function tests that the result type can hold the output of the calculation without overflowing. This check is removed for the mpz_class type</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integral - \( a^b\) mod \( n \) </dd></dl>

</div>
</div>
<a class="anchor" id="a93f24268856fbd366cb688640736fb60"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Integral , class UniformRandomBitGenerator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Integral cryptomath::randomPrime </td>
          <td>(</td>
          <td class="paramtype">UniformRandomBitGenerator &amp;&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>bitcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>prime_reps</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for _randomPrime that verifies that the output type can hold the prime without overflow. </p>
<p>For non-standard types, specialize the hasBits templated function to verify that a type can be used</p>
<p>Template arguments</p><ul>
<li>class Integral - Some integer type</li>
<li>class UniformRandomBitGenerator - Some type meeting the C++ UniformRandomBitGenerator specification</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bits</td><td>- A random bit generator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bitcount</td><td>- Number of bits in final value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prime_reps</td><td>- Number of iterations to do probabalistic primality test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integral - A random prime with the specified number of bits </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">logic_error</td><td>: Integral type cannot hold a prime of the size requested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9e16705865a198f4d3b0227619a85596"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Integral &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Integral cryptomath::sqrtfloor </td>
          <td>(</td>
          <td class="paramtype">const Integral &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Floor of square root. </p>
<p>Template arguments</p><ul>
<li>class Integral - Some integer type</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Value to square root </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integral - Square root of n rounded down </dd></dl>

</div>
</div>
<a class="anchor" id="abfcd8397f758faec532f382662223fb6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mpz_class <a class="el" href="namespacecryptomath.html#a9e16705865a198f4d3b0227619a85596">cryptomath::sqrtfloor</a>&lt; mpz_class &gt; </td>
          <td>(</td>
          <td class="paramtype">const mpz_class &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Template specialization of <a class="el" href="namespacecryptomath.html#a9e16705865a198f4d3b0227619a85596" title="Floor of square root. ">sqrtfloor()</a> for mpz_class</p>
<p>Returns the floor of the square root of a number as an integer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>- Number to find square root of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mpz_class - Floor of square root of n </dd></dl>

</div>
</div>
<a class="anchor" id="a6964cc63e189eadb8c74202df0fd0040"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Integral &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cryptomath::sundaramSieve </td>
          <td>(</td>
          <td class="paramtype">const Integral &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Integral &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sundaram's sieve for finding prime numbers. </p>
<p>The sieve of Sundaram finds all the prime numbers less than some \( n \). Start with a list of all numbers less than \( n \). For all \( i, j \) greater than equal to 1, where \( i+j+2ij\) is less than or equal to \( n \), \( i+j+2ij \) is removed. For all remaining values, \( i \), \( 2i + 1 \) is prime.</p>
<p>Template arguments</p><ul>
<li>class Integral - Some integer type which can be used to index into a vector (mpz_class will not work)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>- Number to find primes less than </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>- Vector to store results in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 11 2017 17:22:28 for Crypto Module by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
